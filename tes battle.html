<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPG 3D PERFECTION - ADAPTIVE 555px</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/23.1.1/tween.umd.js"></script>
<script src="tween.umd.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; height: 100vh; }
        #game-container { width: 100vw; height: 100vh; position: relative; display: flex; overflow: hidden; }
        
        canvas { display: block; flex-grow: 1; transition: filter 0.1s; min-width: 0; }
        .timestop-filter { filter: invert(1) hue-rotate(180deg) brightness(1.2); }
        .glass-shatter { animation: shatter 0.2s ease-out; }
        @keyframes shatter {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); filter: brightness(2); }
            100% { transform: scale(1); }
        }

        #camera-control {
            position: absolute; top: 10px; left: 10px; z-index: 150;
            pointer-events: auto; color: #00d4ff;
        }
        #active-cam-display {
            background: rgba(5, 5, 20, 0.9); border: 1px solid #00d4ff;
            padding: 4px 10px; font-size: 10px; font-weight: bold;
            cursor: pointer; text-transform: uppercase;
        }
        #camera-options {
            display: none; flex-direction: column; gap: 1px; margin-top: 5px;
            background: rgba(0, 0, 0, 0.9); border: 1px solid #00d4ff; padding: 3px;
        }
        .cam-option {
            background: transparent; border: none; color: #00d4ff;
            padding: 5px 10px; font-size: 9px; text-align: left;
            cursor: pointer; width: 100%; text-transform: uppercase;
        }
        .cam-option:hover { background: #00d4ff; color: #000; }

        #skill-banner {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            background: linear-gradient(to right, transparent, rgba(0, 212, 255, 0.8), transparent);
            color: white; padding: 5px 40px; font-size: 18px; font-weight: bold;
            display: none; z-index: 1100; text-shadow: 2px 2px 4px #000;
            border-top: 1px solid #00d4ff; border-bottom: 1px solid #00d4ff;
            letter-spacing: 3px; font-style: italic; white-space: nowrap;
        }

        #battle-ticker {
            position: absolute; bottom: 5px; left: 5px; color: #00d4ff;
            font-size: 10px; font-family: monospace; z-index: 100;
            background: rgba(0,0,0,0.5); padding: 2px 5px;
        }

        #ui-layer-vertical {
            width: 200px; height: 100%;
            background: linear-gradient(to right, rgba(5, 5, 20, 0.5), rgba(5, 5, 25, 0.98));
            border-left: 2px solid #00d4ff;
            display: flex; flex-direction: column; padding: 10px; box-sizing: border-box; 
            color: white; z-index: 10; pointer-events: auto;
        }
        
        .status-header { 
            font-size: 10px; font-weight: bold; color: #00d4ff; 
            margin-bottom: 8px; border-bottom: 1px solid #00d4ff; padding-bottom: 2px;
            letter-spacing: 1px;
        }

        .status-panel { display: flex; flex-direction: column; gap: 5px; overflow-y: auto; }
        .actor-row { display: flex; flex-direction: column; gap: 1px; margin-bottom: 3px; }
        .actor-info { display: flex; justify-content: space-between; align-items: center; font-size: 10px; }
        .atb-container { width: 100%; height: 3px; background: #222; border: 1px solid #444; border-radius: 1px; overflow: hidden; }
        .atb-fill { height: 100%; width: 0%; background: #0066ff; box-shadow: 0 0 5px #0066ff; }
        
        #command-menu, #target-menu {
            margin-top: auto;
            display: none; flex-direction: column; 
            padding-top: 10px; border-top: 1px solid #333;
        }

        #skill-menu {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 90%; max-width: 420px;
            max-height: 85vh;
            background: rgba(5, 15, 25, 0.98);
            border: 2px solid #00d4ff;
            box-shadow: 0 0 40px rgba(0, 212, 255, 0.4);
            display: none;
            flex-direction: column;
            padding: 15px;
            z-index: 1000;
            backdrop-filter: blur(15px);
            animation: skillFadeIn 0.25s ease-out;
        }

        @keyframes skillFadeIn {
            from { opacity: 0; transform: translate(-50%, -48%) scale(0.98); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .skill-header {
            color: #00d4ff; font-size: 14px; letter-spacing: 2px; font-weight: bold;
            text-align: center; margin-bottom: 10px; border-bottom: 1px solid #00d4ff;
            padding-bottom: 5px; text-transform: uppercase;
        }

        #skill-list {
            display: grid; grid-template-columns: 1fr 1fr; gap: 6px;
            overflow-y: auto; max-height: 200px; padding: 5px;
        }
        #skill-list::-webkit-scrollbar { width: 4px; }
        #skill-list::-webkit-scrollbar-thumb { background: #00d4ff; }

        #skill-desc-box {
            margin-top: 10px; padding: 8px;
            background: rgba(0, 212, 255, 0.1);
            border-left: 3px solid #00d4ff;
            font-size: 10px; min-height: 25px; color: #fff;
            line-height: 1.3; font-style: italic;
        }

        .command-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; }
        .action-btn { 
            background: rgba(0, 212, 255, 0.05); color: white; border: 1px solid #00d4ff; 
            padding: 6px 4px; cursor: pointer; font-weight: bold; text-align: center;
            transition: 0.2s; font-size: 9px; text-transform: uppercase;
        }
        .action-btn:hover { background: #00d4ff; color: #000; }
        
        #battle-log { position: absolute; top: 10px; left: 40%; transform: translateX(-50%); color: #00d4ff; font-size: 12px; font-weight: bold; pointer-events: none; z-index: 100; text-shadow: 0 0 5px #000; }
        #loading-screen { position: absolute; width: 100%; height: 100%; background: #000; color: #00d4ff; display: flex; align-items: center; justify-content: center; z-index: 200; font-size: 18px; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="loading-screen">LOADING TIMECHAMBER...</div>
    <div id="skill-banner">SKILL NAME</div>
    <div id="battle-ticker">TIME: 00:00:00</div>
    
    <div id="camera-control">
        <div id="active-cam-display" onclick="toggleCamMenu()">CAM: CLOCKWISE ORBIT</div>
        <div id="camera-options">
            <button class="cam-option" onclick="changeCam('clockwise', 'CLOCKWISE ORBIT')">CLOCKWISE ORBIT</button>
            <button class="cam-option" onclick="changeCam('fp_ally', 'FP ALLY (REAR)')">FP ALLY (REAR)</button>
            <button class="cam-option" onclick="changeCam('fp_enemy', 'FP ENEMY (FRONT)')">FP ENEMY (FRONT)</button>
            <button class="cam-option" onclick="changeCam('sideview', 'SIDEVIEW')">SIDEVIEW</button>
            <button class="cam-option" onclick="changeCam('big_enemy', 'BIG ENEMY (LOW)')">BIG ENEMY (LOW)</button>
        </div>
    </div>

    <div id="battle-log">READY</div>

    <div id="skill-menu">
        <div class="skill-header">Techniques</div>
        <div id="skill-list"></div>
        <div id="skill-desc-box">Select a skill to see details.</div>
        <button class="action-btn" style="margin-top:10px; width:100%; border-color:#ff4444; color:#ff4444;" onclick="window.backToCommand()">BACK</button>
    </div>

    <div id="ui-layer-vertical">
        <div class="status-header">PARTY STATUS</div>
        <div class="status-panel" id="party-ui"></div>
        
        <div id="command-menu">
            <div style="color:#00d4ff; font-size: 8px; margin-bottom: 4px; font-weight: bold; text-align: center;">SELECT ACTION</div>
            <div class="command-grid">
                <button class="action-btn" onclick="window.triggerAction('attack')">ATTACK</button>
                <button class="action-btn" onclick="window.triggerAction('magic')">MAGIC</button>
                <button class="action-btn" onclick="window.triggerAction('guard')">GUARD</button>
                <button class="action-btn" onclick="window.triggerAction('escape')">ESCAPE</button>
            </div>
        </div>

        <div id="target-menu">
            <div style="color:#ffcc00; font-size: 8px; margin-bottom: 4px; font-weight: bold; text-align: center;">SELECT TARGET</div>
            <div class="command-grid" id="target-list"></div>
            <button class="action-btn" style="margin-top:5px; border-color:#ff4444; color:#ff4444;" onclick="window.backToCommand()">BACK</button>
        </div>
    </div>
</div>

<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
</script>

<script type="module">
import * as THREE from 'three';
import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';

let width = window.innerWidth - 200, height = window.innerHeight;
let isAnimating = false, activeActor = null, focusMode = null, isReturning = false, camTargetPos = null;
let orbitAngle = 0, shakeIntensity = 0, battleTimer = 0;
let currentCamMode = 'clockwise';

const skillDatabase = [
    { id: 100, name: "STRIKE", type: "attack", desc: "A basic physical strike dealing moderate damage." },
    { id: 101, name: "HEAVY JUMP", type: "jump", desc: "Leap high and crush the enemy from above." },
    { id: 102, name: "SONIC DASH", type: "dashslash", desc: "A high-speed dash that cuts through time and space." },
    { id: 103, name: "FIRE BALL", type: "projectile", desc: "Launch a concentrated orb of pure flame." },
    { id: 104, name: "SWING", type: "swing", desc: "Spin with momentum to hit the target repeatedly." },
    { id: 105, name: "HAND GUN", type: "gun", desc: "Precise long-range shot focused on weak points." },
    { id: 106, name: "TORNADO", type: "tornado", desc: "Create a localized vortex to shred the enemy." },
    { id: 107, name: "EARTHQUAKE", type: "earthquake", desc: "Shake the very foundation of the battlefield." },
    { id: 108, name: "SUPLEX", type: "suplex", desc: "Grapple the enemy and slam them into the dirt." },
    { id: 109, name: "LEAP", type: "leap", desc: "Dive into the ground and emerge beneath the foe." },
    { id: 110, name: "LIONHEART", type: "lionheart", desc: "10-hit rapid combo ending with a massive burst." },
    { id: 111, name: "TIME STOP", type: "timestop", desc: "Invert reality and strike while time is frozen." },
    { id: 113, name: "METEOR DRIVE", type: "meteor_drive", desc: "Take them to heaven and bring them back to hell." },
    { id: 115, name: "ROUGH DIVIDE", type: "rough_divide", desc: "Charge, pause, and launch a vertical strike." },
    { id: 116, name: "SATELLITE LASER", type: "satellite_laser", desc: "Orbital strike from the heavens." },
    { id: 117, name: "POSITRON LASER", type: "positron_laser", desc: "High-energy beam directly from the source." },
    { id: 118, name: "METEOR", type: "meteor", desc: "Summon a celestial body to crush the foe." },
    { id: 119, name: "FLY", type: "fly", desc: "Control the gravitational pull and make the target melayang." },
    { id: 120, name: "HIRAISHIN", type: "hiraishin", desc: "Instant teleport strike behind the enemy." }
];

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050510);
const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 2000);
const renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
renderer.setSize(width, height);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.getElementById('game-container').prepend(renderer.domElement);

const clock = new THREE.Clock();
const camLookAt = new THREE.Vector3(0, 0, 0);
scene.add(new THREE.AmbientLight(0xffffff, 1.2));

window.addEventListener('resize', () => {
    width = window.innerWidth - 200;
    height = window.innerHeight;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
});

window.toggleCamMenu = () => {
    const menu = document.getElementById('camera-options');
    menu.style.display = menu.style.display === 'flex' ? 'none' : 'flex';
};

window.changeCam = (mode, label) => {
    currentCamMode = mode;
    document.getElementById('active-cam-display').innerText = `CAM: ${label}`;
    document.getElementById('camera-options').style.display = 'none';
};

const mtlLoader = new MTLLoader();
mtlLoader.load('Battlefield/Timechamber.mtl', (materials) => {
    materials.preload();
    const objLoader = new OBJLoader();
    objLoader.setMaterials(materials);
    objLoader.load('Battlefield/Timechamber.obj', (obj) => {
        scene.add(obj);
        document.getElementById('loading-screen').style.display = 'none';
    }, undefined, () => {
        scene.add(new THREE.GridHelper(100, 50, 0x444444, 0x222222));
        document.getElementById('loading-screen').style.display = 'none';
    });
});

const textureLoader = new THREE.TextureLoader();
const spriteTex = textureLoader.load('Act01.png');
spriteTex.magFilter = THREE.NearestFilter;
spriteTex.minFilter = THREE.NearestFilter;
spriteTex.repeat.set(1/3, 1/4);

function createUnitSprite() {
    const tex = spriteTex.clone();
    tex.needsUpdate = true;
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false, alphaTest: 0.1 });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(3, 4, 1);
    sprite.renderOrder = 999;
    return sprite;
}

const actors = [
    { id: 1, name: "RAVINO", pos: [8, 2.01, 5], atb: 0, spd: 15, sprite: null },
    { id: 2, name: "FELINA", pos: [8, 2.01, 2], atb: 0, spd: 22, sprite: null },
    { id: 3, name: "KIERRA", pos: [8, 2.01, -2], atb: 0, spd: 18, sprite: null },
    { id: 4, name: "AL", pos: [8, 2.01, -5], atb: 0, spd: 12, sprite: null }
];
const enemies = [
    { id: 5, name: "BOSS", pos: [-10, 2.51, 0], scale: [5, 6.5, 1], sprite: null },
    { id: 6, name: "GUARD L", pos: [-9, 2.01, 4], scale: [3, 4, 1], sprite: null },
    { id: 7, name: "GUARD R", pos: [-9, 2.01, -4], scale: [3, 4, 1], sprite: null }
];

function initUnits() {
    const ui = document.getElementById('party-ui');
    ui.innerHTML = "";
    actors.forEach(a => {
        a.sprite = createUnitSprite();
        a.sprite.position.set(...a.pos);
        scene.add(a.sprite);
        ui.innerHTML += `
            <div class="actor-row">
                <div class="actor-info"><span>${a.name}</span><span id="atb-text-${a.id}" style="font-size:8px; color:#00d4ff;">0%</span></div>
                <div class="atb-container"><div id="atb-fill-${a.id}" class="atb-fill"></div></div>
            </div>`;
    });
    enemies.forEach(e => {
        e.sprite = createUnitSprite();
        e.sprite.position.set(...e.pos);
        e.sprite.scale.set(...e.scale);
        scene.add(e.sprite);
    });
}

function createSparkEffect(pos) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 64; canvas.height = 64;
    const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    grad.addColorStop(0, 'white');
    grad.addColorStop(0.4, 'yellow');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 64, 64);
    
    const tex = new THREE.CanvasTexture(canvas);
    for(let i=0; i<8; i++) {
        const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, blending: THREE.AdditiveBlending, alphaTest: 0.1 });
        const s = new THREE.Sprite(mat);
        s.position.copy(pos);
        s.position.x += (Math.random()-0.5)*2;
        s.position.y += (Math.random()-0.5)*2;
        s.scale.set(1.5, 1.5, 1);
        scene.add(s);
        new TWEEN.Tween(s.position).to({ x: s.position.x+(Math.random()-0.5)*5, y: s.position.y+(Math.random()-0.5)*5 }, 400).start();
        new TWEEN.Tween(s.material).to({ opacity: 0 }, 400).onComplete(()=>scene.remove(s)).start();
    }
}

function createDamagePopup(targetSprite, text = "9999") {
    createSparkEffect(targetSprite.position);
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 256; canvas.height = 128;
    ctx.clearRect(0,0,256,128);
    ctx.font = 'bold 80px "Segoe UI"';
    ctx.fillStyle = '#ffff00';
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 6;
    ctx.textAlign = 'center';
    ctx.strokeText(text, 128, 80);
    ctx.fillText(text, 128, 80);

    const tex = new THREE.CanvasTexture(canvas);
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, alphaTest: 0.1 });
    const sprite = new THREE.Sprite(mat);
    sprite.position.copy(targetSprite.position);
    sprite.position.y += 4;
    sprite.scale.set(4, 2, 1);
    scene.add(sprite);

    new TWEEN.Tween(sprite.position).to({ y: sprite.position.y + 3 }, 800).easing(TWEEN.Easing.Quadratic.Out).start();
    new TWEEN.Tween(mat).to({ opacity: 0 }, 800).onComplete(() => scene.remove(sprite)).start();
}

function flashTarget(targetSprite) {
    const mat = targetSprite.material;
    const originalColor = mat.color.clone();
    mat.blending = THREE.AdditiveBlending;
    mat.color.set(0xffffff); 
    createDamagePopup(targetSprite);
    setTimeout(() => {
        mat.blending = THREE.NormalBlending;
        mat.color.copy(originalColor);
    }, 120);
}

function createBeam(start, end, size=1) {
    const geom = new THREE.CylinderGeometry(size, size, 1, 16);
    const mat = new THREE.MeshBasicMaterial({ color: 0x00d4ff, transparent: true, opacity: 0.8 });
    const mesh = new THREE.Mesh(geom, mat);
    const direction = new THREE.Vector3().subVectors(end, start);
    mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.clone().normalize());
    mesh.position.addVectors(start, end).multiplyScalar(0.5);
    mesh.scale.set(1, direction.length(), 1);
    scene.add(mesh);
    new TWEEN.Tween(mat).to({ opacity: 0 }, 500).onComplete(() => scene.remove(mesh)).start();
}

function showSkillName(name) {
    const banner = document.getElementById('skill-banner');
    banner.innerText = name.toUpperCase();
    banner.style.display = 'block';
    setTimeout(() => { banner.style.display = 'none'; }, 2000);
}

function createAfterimage(sprite) {
    const ghostMat = sprite.material.clone();
    ghostMat.transparent = true;
    ghostMat.opacity = 0.4;
    const ghost = new THREE.Sprite(ghostMat);
    ghost.position.copy(sprite.position);
    ghost.scale.copy(sprite.scale);
    ghost.material.rotation = sprite.material.rotation;
    scene.add(ghost);
    new TWEEN.Tween(ghostMat).to({ opacity: 0 }, 300).onComplete(() => scene.remove(ghost)).start();
}

function updateFacingLogic() {
    enemies.forEach(e => updateSingleFacing(e.sprite, actors[0].sprite));
    actors.forEach(a => {
        if (isAnimating && a === activeActor) return;
        updateSingleFacing(a.sprite, enemies[0].sprite);
    });
}

function updateSingleFacing(sprite, target) {
    if (!sprite || !target) return;
    let frameY = 0;
    const isEnemy = enemies.some(e => e.sprite === sprite);
    if (currentCamMode === 'fp_ally') frameY = isEnemy ? 0 : 3;
    else if (currentCamMode === 'fp_enemy') frameY = isEnemy ? 3 : 0;
    else if (currentCamMode === 'sideview') frameY = isEnemy ? 2 : 1;
    else {
        const unitProj = sprite.position.clone().project(camera);
        const targetProj = target.position.clone().project(camera);
        const distUnit = camera.position.distanceTo(sprite.position);
        const distTarget = camera.position.distanceTo(target.position);
        const depthDiff = distUnit - distTarget;
        if (Math.abs(depthDiff) > 8) frameY = (depthDiff < 0) ? 3 : 0;
        else frameY = (targetProj.x < unitProj.x) ? 1 : 2;
    }
    sprite.material.map.offset.y = (3 - frameY) / 4;
}

function updateTicker() {
    battleTimer += 1/60; 
    const hours = Math.floor(battleTimer / 3600).toString().padStart(2, '0');
    const mins = Math.floor((battleTimer % 3600) / 60).toString().padStart(2, '0');
    const secs = Math.floor(battleTimer % 60).toString().padStart(2, '0');
    document.getElementById('battle-ticker').innerText = `TIME: ${hours}:${mins}:${secs}`;
}

function updateATB() {
    if (isAnimating || activeActor) return;
    actors.forEach(a => {
        const text = document.getElementById(`atb-text-${a.id}`);
        if (a.atb < 100) {
            a.atb += a.spd * 0.05;
            text.innerText = Math.floor(a.atb) + "%";
            const bar = document.getElementById(`atb-fill-${a.id}`);
            if (bar) bar.style.width = Math.min(a.atb, 100) + "%";
            if (a.atb >= 100) { a.atb = 100; text.innerText = "READY"; openMenu(a); }
        }
    });
}

function openMenu(actor) {
    activeActor = actor;
    document.getElementById('command-menu').style.display = 'flex';
}

window.backToCommand = () => {
    if (!activeActor) return;
    document.getElementById('skill-menu').style.display = 'none';
    document.getElementById('target-menu').style.display = 'none';
    document.getElementById('command-menu').style.display = 'flex';
}

window.triggerAction = (type) => {
    if (!activeActor || isAnimating) return;
    
    if (type === 'magic') {
        const list = document.getElementById('skill-list');
        const descBox = document.getElementById('skill-desc-box');
        list.innerHTML = ""; descBox.innerText = "Select a skill to see details.";
        skillDatabase.forEach(skill => {
            const btn = document.createElement('button');
            btn.className = 'action-btn'; btn.style.padding = '10px 4px'; btn.innerText = skill.name;
            btn.onmouseover = () => { descBox.innerText = skill.desc; };
            btn.onclick = () => { window.executeSkill(skill); };
            list.appendChild(btn);
        });
        document.getElementById('command-menu').style.display = 'none';
        document.getElementById('skill-menu').style.display = 'flex';
        return;
    }
    
    if (type === 'attack') {
        const tList = document.getElementById('target-list');
        tList.innerHTML = "";
        enemies.forEach((en, index) => {
            const btn = document.createElement('button');
            btn.className = 'action-btn'; btn.innerText = en.name;
            btn.onclick = () => { 
                document.getElementById('target-menu').style.display = 'none';
                executeActionLogic('attack', null, index); 
            };
            tList.appendChild(btn);
        });
        document.getElementById('command-menu').style.display = 'none';
        document.getElementById('target-menu').style.display = 'flex';
        return;
    }

    document.getElementById('command-menu').style.display = 'none';
    if (type === 'escape') { runEscape(); return; }
    executeActionLogic(type);
};

window.executeSkill = (skill) => {
    if (!activeActor || isAnimating) return;
    document.getElementById('skill-menu').style.display = 'none';
    showSkillName(skill.name);
    executeActionLogic(skill.type, skill.id);
};

function executeActionLogic(type, animId = null, targetIdx = 0) {
    isAnimating = true; isReturning = false;
    const sprite = activeActor.sprite;
    const startX = activeActor.pos[0], startY = activeActor.pos[1], startZ = activeActor.pos[2];
    const eTarget = enemies[targetIdx];
    const eSprite = eTarget.sprite;
    const targetX = eSprite.position.x, targetZ = eSprite.position.z;
    const eOrigY = eTarget.pos[1];

    if (type === 'rough_divide') {
        focusMode = 'attack'; // PERFECTION: No lock sideview
        new TWEEN.Tween(sprite.position).to({ x: targetX + 5, z: targetZ }, 400).onComplete(() => {
            setTimeout(() => {
                new TWEEN.Tween(sprite.position).to({ y: 15 }, 300).easing(TWEEN.Easing.Quadratic.Out)
                .onStart(() => { flashTarget(eSprite); })
                .onUpdate(() => { createAfterimage(sprite); })
                .onComplete(() => {
                    new TWEEN.Tween(sprite.position).to({ y: startY, x: startX, z: startZ }, 500).onComplete(finishAction).start();
                }).start();
            }, 200);
        }).start();
    }
    else if (type === 'satellite_laser') {
        focusMode = 'low_view'; // PERFECTION: Low angle zoom far
        setTimeout(() => {
            createBeam(new THREE.Vector3(targetX, 60, targetZ), new THREE.Vector3(targetX, startY, targetZ), 3);
            shakeIntensity = 1.5;
            flashTarget(eSprite);
            setTimeout(() => {
                shakeIntensity = 0;
                finishAction();
            }, 600);
        }, 500);
    }
    else if (type === 'positron_laser') {
        camTargetPos = new THREE.Vector3().lerpVectors(sprite.position, eSprite.position, 0.5);
        camera.fov = 35;
        setTimeout(() => {
            const laserStart = sprite.position.clone().add(new THREE.Vector3(-1.5, 0, 0));
            const laserEnd = laserStart.clone().add(new THREE.Vector3(-60, 0, 0));
            createBeam(laserStart, laserEnd, 1.5);
            flashTarget(eSprite);
            setTimeout(() => {
                camTargetPos = null;
                finishAction();
            }, 500);
        }, 400);
    }
    else if (type === 'meteor') {
        const randCam = Math.random() < 0.5 ? 'drone_view' : 'low_view';
        focusMode = randCam;
        let hits = 0;
        const spawnMeteor = () => {
            if (hits < 5) {
                const met = new THREE.Mesh(new THREE.SphereGeometry(3, 16, 16), new THREE.MeshBasicMaterial({ color: 0xff4400 }));
                met.position.set(targetX + (Math.random()-0.5)*10, 50, targetZ + (Math.random()-0.5)*10);
                scene.add(met);
                new TWEEN.Tween(met.position).to({ x: targetX, y: startY, z: targetZ }, 600).easing(TWEEN.Easing.Quadratic.In).onComplete(() => {
                    scene.remove(met);
                    shakeIntensity = (focusMode === 'drone_view') ? 2.5 : 1.0; // PERFECTION: Drone ga stabil (lebih shake)
                    flashTarget(eSprite);
                    setTimeout(() => { shakeIntensity = 0; }, 100);
                }).start();
                hits++;
                setTimeout(spawnMeteor, 200);
            } else {
                setTimeout(finishAction, 1000);
            }
        };
        spawnMeteor();
    }
    else if (type === 'fly') {
        new TWEEN.Tween(eSprite.position).to({ y: 15 }, 1200).easing(TWEEN.Easing.Quadratic.Out).onComplete(finishAction).start();
    }
    else if (type === 'hiraishin') {
        // PERFECTION: Kamera ke belakang target dulu
        camTargetPos = new THREE.Vector3(targetX - 10, startY + 2, targetZ); 
        setTimeout(() => {
            new TWEEN.Tween(sprite.material).to({ opacity: 0 }, 100).onComplete(() => {
                sprite.position.set(targetX - 4, startY, targetZ);
                new TWEEN.Tween(sprite.material).to({ opacity: 1 }, 100).onComplete(() => {
                    flashTarget(eSprite);
                    setTimeout(() => {
                        camTargetPos = null;
                        new TWEEN.Tween(sprite.position).to({ x: startX, z: startZ }, 400).onComplete(finishAction).start();
                    }, 400);
                }).start();
            }).start();
        }, 300); // PERFECTION: Jeda 0.3s
    }
    else if (type === 'lionheart') {
        focusMode = 'attack';
        camera.fov = 30;
        let hits = 0;
        const totalHits = 10;
        const multihit = () => {
            if (hits < totalHits) {
                const offset = hits % 2 === 0 ? 4 : -4;
                new TWEEN.Tween(sprite.position).to({ x: targetX + offset, z: targetZ + (Math.random()-0.5)*2 }, 80).onComplete(() => {
                    flashTarget(eSprite);
                    createAfterimage(sprite);
                    hits++;
                    multihit();
                }).start();
            } else {
                shakeIntensity = 1.5;
                flashTarget(eSprite);
                setTimeout(() => {
                    shakeIntensity = 0;
                    new TWEEN.Tween(sprite.position).to({ x: startX, y: startY, z: startZ }, 500).onComplete(finishAction).start();
                }, 400);
            }
        };
        multihit();
    }
    else if (type === 'timestop') {
        focusMode = 'attack';
        camera.fov = 30;
        new TWEEN.Tween(sprite.position).to({ x: targetX + 4 }, 300).onComplete(() => {
            document.querySelector('canvas').classList.add('timestop-filter');
            setTimeout(() => {
                document.querySelector('canvas').classList.remove('timestop-filter');
                document.querySelector('canvas').classList.add('glass-shatter');
                flashTarget(eSprite);
                shakeIntensity = 1.0;
                setTimeout(() => {
                    document.querySelector('canvas').classList.remove('glass-shatter');
                    shakeIntensity = 0;
                    new TWEEN.Tween(sprite.position).to({ x: startX, z: startZ }, 400).onComplete(finishAction).start();
                }, 300);
            }, 1000);
        }).start();
    }
    else if (type === 'meteor_drive') {
        camTargetPos = sprite.position;
        camera.fov = 35;
        new TWEEN.Tween(sprite.position).to({ x: targetX + 2, z: targetZ }, 300).onComplete(() => {
            new TWEEN.Tween(sprite.position).to({ y: 20 }, 600).easing(TWEEN.Easing.Quadratic.Out)
                .onUpdate(() => { 
                    eSprite.position.set(sprite.position.x - 2, sprite.position.y, sprite.position.z);
                    createAfterimage(sprite);
                }).onComplete(() => {
                    setTimeout(() => {
                        new TWEEN.Tween(sprite.position).to({ y: startY }, 200).easing(TWEEN.Easing.Quadratic.In)
                        .onUpdate(() => { eSprite.position.y = sprite.position.y; })
                        .onComplete(() => {
                            shakeIntensity = 2.0;
                            flashTarget(eSprite);
                            camera.fov = 25;
                            setTimeout(() => {
                                shakeIntensity = 0;
                                camTargetPos = null;
                                eSprite.position.y = eOrigY;
                                new TWEEN.Tween(sprite.position).to({ x: startX, z: startZ }, 500).onComplete(finishAction).start();
                            }, 500);
                        }).start();
                    }, 300);
                }).start();
        }).start();
    }
    else if (type === 'guard') {
        const jumpObj = { y: startY };
        new TWEEN.Tween(jumpObj).to({ y: 7 }, 450).easing(TWEEN.Easing.Quadratic.Out)
            .onUpdate(() => { sprite.position.y = jumpObj.y; })
            .onComplete(() => {
                new TWEEN.Tween(jumpObj).to({ y: startY }, 450).easing(TWEEN.Easing.Quadratic.In)
                    .onUpdate(() => { sprite.position.y = jumpObj.y; })
                    .onComplete(finishAction).start();
            }).start();
    } 
    else if (type === 'jump') {
        focusMode = 'attack';
        camera.fov = 30;
        new TWEEN.Tween(sprite.position).to({ x: targetX, y: 18, z: targetZ }, 400).easing(TWEEN.Easing.Quadratic.Out)
        .onComplete(() => {
            setTimeout(() => {
                new TWEEN.Tween(sprite.position).to({ y: startY + 0.5 }, 200).easing(TWEEN.Easing.Quadratic.In)
                .onUpdate(() => createAfterimage(sprite))
                .onComplete(() => {
                    flashTarget(eSprite);
                    setTimeout(() => {
                        new TWEEN.Tween(sprite.position).to({ x: startX, y: startY, z: startZ }, 500).onComplete(finishAction).start();
                    }, 300);
                }).start();
            }, 200);
        }).start();
    }
    else if (type === 'dashslash') {
        focusMode = 'attack';
        camera.fov = 30;
        new TWEEN.Tween(sprite.position).to({ x: targetX - 8, z: targetZ }, 300).easing(TWEEN.Easing.Exponential.In)
        .onUpdate(() => createAfterimage(sprite))
        .onComplete(() => {
            flashTarget(eSprite);
            setTimeout(() => {
                new TWEEN.Tween(sprite.position).to({ x: startX, z: startZ }, 500).onComplete(finishAction).start();
            }, 500);
        }).start();
    }
    else if (type === 'swing') {
        focusMode = 'attack';
        camera.fov = 35;
        let swingTimer = 0;
        const originalScaleX = sprite.scale.x;
        new TWEEN.Tween(sprite.position).to({ x: targetX + 2, z: targetZ }, 500)
        .onUpdate(() => {
            swingTimer += 0.4;
            sprite.scale.x = Math.cos(swingTimer) * originalScaleX;
            createAfterimage(sprite);
        })
        .onComplete(() => {
            flashTarget(eSprite);
            sprite.scale.x = originalScaleX;
            setTimeout(() => {
                new TWEEN.Tween(sprite.position).to({ x: startX, z: startZ }, 500).onComplete(finishAction).start();
            }, 400);
        }).start();
    }
    else if (type === 'suplex') {
        camTargetPos = sprite.position; 
        camera.fov = 30;
        new TWEEN.Tween(sprite.position).to({ x: targetX + 1.5, z: targetZ }, 400).easing(TWEEN.Easing.Quadratic.Out)
        .onComplete(() => {
            new TWEEN.Tween(eSprite.position).to({ y: eSprite.position.y + 4 }, 200).start();
            new TWEEN.Tween(sprite.position).to({ y: startY + 1 }, 200).onComplete(() => {
                new TWEEN.Tween(sprite.position).to({ y: 15 }, 600).easing(TWEEN.Easing.Quadratic.Out)
                .onUpdate(() => {
                    eSprite.position.set(sprite.position.x, sprite.position.y + 4, sprite.position.z);
                    eSprite.material.rotation = Math.PI; 
                    sprite.material.rotation += 0.2; 
                })
                .onComplete(() => {
                    camTargetPos = eSprite.position; 
                    shakeIntensity = 1.2;
                    new TWEEN.Tween(sprite.position).to({ y: startY }, 300).easing(TWEEN.Easing.Quadratic.In)
                    .onUpdate(() => {
                        eSprite.position.set(sprite.position.x, sprite.position.y + 3, sprite.position.z);
                        createAfterimage(sprite);
                    })
                    .onComplete(() => {
                        flashTarget(eSprite);
                        sprite.material.rotation = 0;
                        setTimeout(() => {
                            shakeIntensity = 0;
                            camTargetPos = null;
                            eSprite.material.rotation = 0; 
                            new TWEEN.Tween(eSprite.position).to({ y: eOrigY }, 200).start();
                            new TWEEN.Tween(sprite.position).to({ x: startX, z: startZ }, 500).onComplete(finishAction).start();
                        }, 500);
                    }).start();
                }).start();
            }).start();
        }).start();
    }
    else if (type === 'leap') {
        new TWEEN.Tween(sprite.position).to({ y: -5 }, 400).easing(TWEEN.Easing.Quadratic.In)
        .onComplete(() => {
            camTargetPos = eSprite.position; 
            sprite.position.set(targetX, -5, targetZ);
            setTimeout(() => {
                shakeIntensity = 0.8;
                new TWEEN.Tween(sprite.position).to({ y: 8 }, 300).easing(TWEEN.Easing.Quadratic.Out)
                .onUpdate(() => {
                    sprite.material.rotation += 0.8;
                    createAfterimage(sprite);
                })
                .onComplete(() => {
                    flashTarget(eSprite);
                    new TWEEN.Tween(eSprite.position).to({ y: 12 }, 400).easing(TWEEN.Easing.Quadratic.Out).yoyo(true).repeat(1).start();
                    setTimeout(() => {
                        shakeIntensity = 0;
                        sprite.material.rotation = 0;
                        camTargetPos = null; 
                        new TWEEN.Tween(sprite.position).to({ x: startX, y: startY, z: startZ }, 500).onComplete(finishAction).start();
                    }, 400);
                }).start();
            }, 600);
        }).start();
    }
    else if (type === 'tornado') {
        focusMode = 'attack';
        camera.fov = 35;
        new TWEEN.Tween(sprite.position).to({ x: targetX + 2, z: targetZ }, 500)
        .onUpdate(() => {
            sprite.material.rotation -= 0.6; 
            createAfterimage(sprite);
        })
        .onComplete(() => {
            flashTarget(eSprite);
            sprite.material.rotation = 0;
            setTimeout(() => {
                new TWEEN.Tween(sprite.position).to({ x: startX, z: startZ }, 500).onComplete(finishAction).start();
            }, 400);
        }).start();
    }
    else if (type === 'earthquake') {
        focusMode = 'global_view'; // PERFECTION: Zoom ga terlalu dekat
        shakeIntensity = 0.6;
        enemies.forEach(en => {
            new TWEEN.Tween(en.sprite.position).to({ y: en.pos[1] + 3 }, 100).yoyo(true).repeat(10).onComplete(() => {
                flashTarget(en.sprite);
            }).start();
        });
        setTimeout(() => {
            shakeIntensity = 0;
            finishAction();
        }, 1500);
    }
    else if (type === 'projectile') {
        camera.fov = 35;
        new TWEEN.Tween(sprite.position).to({ x: startX - 2 }, 300).onComplete(() => {
            camTargetPos = sprite.position.clone();
            setTimeout(() => {
                camTargetPos = eSprite.position.clone();
                setTimeout(() => {
                    flashTarget(eSprite);
                    setTimeout(() => {
                        camTargetPos = null;
                        new TWEEN.Tween(sprite.position).to({ x: startX }, 300).onComplete(finishAction).start();
                    }, 600);
                }, 400);
            }, 500);
        }).start();
    }
    else if (type === 'gun') {
        // PERFECTION: Penyerang maju dikit
        new TWEEN.Tween(sprite.position).to({ x: startX - 3 }, 300).onComplete(() => {
            focusMode = 'gun_view'; 
            camTargetPos = new THREE.Vector3().lerpVectors(sprite.position, eSprite.position, 0.5);
            setTimeout(() => {
                flashTarget(eSprite);
                setTimeout(() => {
                    camTargetPos = null;
                    new TWEEN.Tween(sprite.position).to({ x: startX }, 200).onComplete(finishAction).start();
                }, 500);
            }, 300);
        }).start();
    }
    else if (type === 'attack') {
        new TWEEN.Tween(sprite.position).to({ x: targetX + 3, z: targetZ }, 400)
            .onComplete(() => {
                flashTarget(eSprite);
                setTimeout(() => {
                    new TWEEN.Tween(sprite.position).to({ x: startX, z: startZ }, 400).onComplete(finishAction).start();
                }, 200);
            }).start();
    }
}

function runEscape() {
    isAnimating = true;
    document.getElementById('battle-log').innerText = "ESCAPING...";
    actors.forEach(a => {
        const dir = new THREE.Vector3().copy(a.sprite.position).normalize();
        new TWEEN.Tween(a.sprite.position).to({ x: a.sprite.position.x + (dir.x * 20), z: a.sprite.position.z + (dir.z * 20) }, 1500).start();
        new TWEEN.Tween(a.sprite.material).to({ opacity: 0 }, 1500).onComplete(() => {
            setTimeout(() => location.reload(), 1000);
        }).start();
    });
}

function finishAction() {
    isReturning = true;
    if (activeActor) activeActor.atb = 0;
    setTimeout(() => { 
        isAnimating = false; activeActor = null; focusMode = null; isReturning = false; 
        document.getElementById('command-menu').style.display = 'none';
        document.getElementById('skill-menu').style.display = 'none';
        document.getElementById('target-menu').style.display = 'none';
    }, 400);
}

function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();
    updateTicker();

    let targetOrbitPos = new THREE.Vector3();
    let targetFOV = 45;
    const dt = clock.getDelta();
    
    switch(currentCamMode) {
        case 'clockwise':
            orbitAngle += dt * 0.15;
            targetOrbitPos.set(Math.sin(orbitAngle) * 28, 15, Math.cos(orbitAngle) * 28);
            break;
        case 'fp_ally': targetOrbitPos.set(25, 12, 0); break;
        case 'fp_enemy': targetOrbitPos.set(-25, 12, 0); break;
        case 'sideview': targetOrbitPos.set(0, 18, 22); break;
        case 'big_enemy':
            orbitAngle += dt * 0.10;
            targetOrbitPos.set(Math.sin(orbitAngle) * 32, 2.5, Math.cos(orbitAngle) * 32);
            break;
    }

    if (focusMode === 'low_view') {
        camera.position.lerp(new THREE.Vector3(-35, 4, 15), 0.08);
        camLookAt.lerp(new THREE.Vector3(-10, 5, 0), 0.08);
        targetFOV = 35;
    } else if (focusMode === 'global_view') {
        camera.position.lerp(new THREE.Vector3(0, 25, 40), 0.05);
        camLookAt.lerp(new THREE.Vector3(-5, 0, 0), 0.05);
    } else if (focusMode === 'drone_view') {
        camera.position.lerp(new THREE.Vector3(-10, 50, 0), 0.1);
        camLookAt.lerp(new THREE.Vector3(-10, 0, 0), 0.1);
    } else if (focusMode === 'gun_view' && camTargetPos) {
        camera.position.lerp(targetOrbitPos.clone().normalize().multiplyScalar(22).add(camTargetPos), 0.1);
        camLookAt.lerp(camTargetPos, 0.1);
    } else if (camTargetPos) {
        camera.position.lerp(targetOrbitPos.clone().normalize().multiplyScalar(13).add(camTargetPos), 0.12);
        camLookAt.lerp(camTargetPos, 0.12);
    } else if (focusMode && activeActor && !isReturning) {
        let tp = activeActor.sprite.position;
        camera.position.lerp(targetOrbitPos.clone().normalize().multiplyScalar(18).add(tp), 0.15);
        camLookAt.lerp(tp, 0.15);
    } else {
        camera.position.lerp(targetOrbitPos, 0.05);
        camLookAt.lerp(new THREE.Vector3(0, 0, 0), 0.05);
    }

    if (shakeIntensity > 0) {
        camera.position.x += (Math.random() - 0.5) * shakeIntensity;
        camera.position.y += (Math.random() - 0.5) * shakeIntensity;
    }

    camera.fov += (targetFOV - camera.fov) * 0.1;
    camera.updateProjectionMatrix();

    camera.lookAt(camLookAt);
    updateFacingLogic();
    updateATB();
    renderer.render(scene, camera);
}

initUnits();
animate();
</script>
</body>
</html>
